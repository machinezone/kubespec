# Code generated by kubegen: DO NOT EDIT

from typing import Dict, List, Optional

import addict
from k8s import base
from k8s.apimachinery.meta import v1 as metav1
from korps import types
from typeguard import typechecked


FailurePolicyType = base.Enum('FailurePolicyType', {
    # Fail means that an error calling the webhook causes the admission to fail.
    'Fail': 'Fail',
    # Ignore means that an error calling the webhook is ignored.
    'Ignore': 'Ignore',
})


# MatchPolicyType specifies the type of match policy
MatchPolicyType = base.Enum('MatchPolicyType', {
    # Equivalent means requests should be sent to the webhook if they modify a resource listed in rules via another API group or version.
    'Equivalent': 'Equivalent',
    # Exact means requests should only be sent to the webhook if they exactly match a given rule
    'Exact': 'Exact',
})


OperationType = base.Enum('OperationType', {
    'All': '*',
    'Connect': 'CONNECT',
    'Create': 'CREATE',
    'Delete': 'DELETE',
    'Update': 'UPDATE',
})


# ReinvocationPolicyType specifies what type of policy the admission hook uses.
ReinvocationPolicyType = base.Enum('ReinvocationPolicyType', {
    # IfNeeded indicates that the webhook may be called at least one
    # additional time as part of the admission evaluation if the object being admitted is
    # modified by other admission plugins after the initial webhook call.
    'IfNeeded': 'IfNeeded',
    # Never indicates that the webhook must not be called more than once in a
    # single admission evaluation.
    'Never': 'Never',
})


ScopeType = base.Enum('ScopeType', {
    # All means that all scopes are included.
    'All': '*',
    # Cluster means that scope is limited to cluster-scoped objects.
    # Namespace objects are cluster-scoped.
    'Cluster': 'Cluster',
    # Namespaced means that scope is limited to namespaced objects.
    'Namespaced': 'Namespaced',
})


SideEffectClass = base.Enum('SideEffectClass', {
    # None means that calling the webhook will have no side effects.
    'None': 'None',
    # NoneOnDryRun means that calling the webhook will possibly have side effects, but if the
    # request being reviewed has the dry-run attribute, the side effects will be suppressed.
    'NoneOnDryRun': 'NoneOnDryRun',
    # Some means that calling the webhook will possibly have side effects.
    # If a request with the dry-run attribute would trigger a call to this webhook, the request will instead fail.
    'Some': 'Some',
    # Unknown means that no information is known about the side effects of calling the webhook.
    # If a request with the dry-run attribute would trigger a call to this webhook, the request will instead fail.
    'Unknown': 'Unknown',
})


# Rule is a tuple of APIGroups, APIVersion, and Resources.It is recommended
# to make sure that all the tuple expansions are valid.
class Rule(types.Object):

    @typechecked
    def render(self) -> addict.Dict:
        v = super().render()
        apiGroups = self.apiGroups()
        if apiGroups:  # omit empty
            v['apiGroups'] = apiGroups
        apiVersions = self.apiVersions()
        if apiVersions:  # omit empty
            v['apiVersions'] = apiVersions
        resources = self.resources()
        if resources:  # omit empty
            v['resources'] = resources
        scope = self.scope()
        if scope is not None:  # omit empty
            v['scope'] = scope
        return v
    
    # APIGroups is the API groups the resources belong to. '*' is all groups.
    # If '*' is present, the length of the slice must be one.
    # Required.
    @typechecked
    def apiGroups(self) -> List[str]:
        return self._kwargs.get('apiGroups', [])
    
    # APIVersions is the API versions the resources belong to. '*' is all versions.
    # If '*' is present, the length of the slice must be one.
    # Required.
    @typechecked
    def apiVersions(self) -> List[str]:
        return self._kwargs.get('apiVersions', [])
    
    # Resources is a list of resources this rule applies to.
    # 
    # For example:
    # 'pods' means pods.
    # 'pods/log' means the log subresource of pods.
    # '*' means all resources, but not subresources.
    # 'pods/*' means all subresources of pods.
    # '*/scale' means all scale subresources.
    # '*/*' means all resources and their subresources.
    # 
    # If wildcard is present, the validation rule will ensure resources do not
    # overlap with each other.
    # 
    # Depending on the enclosing object, subresources might not be allowed.
    # Required.
    @typechecked
    def resources(self) -> List[str]:
        return self._kwargs.get('resources', [])
    
    # scope specifies the scope of this rule.
    # Valid values are "Cluster", "Namespaced", and "*"
    # "Cluster" means that only cluster-scoped resources will match this rule.
    # Namespace API objects are cluster-scoped.
    # "Namespaced" means that only namespaced resources will match this rule.
    # "*" means that there are no scope restrictions.
    # Subresources match the scope of their parent resource.
    # Default is "*".
    @typechecked
    def scope(self) -> Optional[ScopeType]:
        return self._kwargs.get('scope')


# RuleWithOperations is a tuple of Operations and Resources. It is recommended to make
# sure that all the tuple expansions are valid.
class RuleWithOperations(types.Object):

    @typechecked
    def render(self) -> addict.Dict:
        v = super().render()
        operations = self.operations()
        if operations:  # omit empty
            v['operations'] = operations
        v.update(self.Rule().render())  # inline
        return v
    
    # Operations is the operations the admission hook cares about - CREATE, UPDATE, or *
    # for all operations.
    # If '*' is present, the length of the slice must be one.
    # Required.
    @typechecked
    def operations(self) -> List[OperationType]:
        return self._kwargs.get('operations', [])
    
    # Rule is embedded, it describes other criteria of the rule, like
    # APIGroups, APIVersions, Resources, etc.
    @typechecked
    def Rule(self) -> Rule:
        return self._kwargs.get('Rule', Rule())


# ServiceReference holds a reference to Service.legacy.k8s.io
class ServiceReference(types.Object):

    @typechecked
    def render(self) -> addict.Dict:
        v = super().render()
        v['namespace'] = self.namespace()
        v['name'] = self.name()
        path = self.path()
        if path is not None:  # omit empty
            v['path'] = path
        port = self.port()
        if port is not None:  # omit empty
            v['port'] = port
        return v
    
    # `namespace` is the namespace of the service.
    # Required
    @typechecked
    def namespace(self) -> str:
        return self._kwargs.get('namespace', '')
    
    # `name` is the name of the service.
    # Required
    @typechecked
    def name(self) -> str:
        return self._kwargs.get('name', '')
    
    # `path` is an optional URL path which will be sent in any request to
    # this service.
    @typechecked
    def path(self) -> Optional[str]:
        return self._kwargs.get('path')
    
    # If specified, the port on the service that hosting webhook.
    # Default to 443 for backward compatibility.
    # `port` should be a valid port number (1-65535, inclusive).
    @typechecked
    def port(self) -> Optional[int]:
        return self._kwargs.get('port', 443)


# WebhookClientConfig contains the information to make a TLS
# connection with the webhook
class WebhookClientConfig(types.Object):

    @typechecked
    def render(self) -> addict.Dict:
        v = super().render()
        url = self.url()
        if url is not None:  # omit empty
            v['url'] = url
        service = self.service()
        if service is not None:  # omit empty
            v['service'] = service
        caBundle = self.caBundle()
        if caBundle:  # omit empty
            v['caBundle'] = caBundle
        return v
    
    # `url` gives the location of the webhook, in standard URL form
    # (`scheme://host:port/path`). Exactly one of `url` or `service`
    # must be specified.
    # 
    # The `host` should not refer to a service running in the cluster; use
    # the `service` field instead. The host might be resolved via external
    # DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
    # in-cluster DNS as that would be a layering violation). `host` may
    # also be an IP address.
    # 
    # Please note that using `localhost` or `127.0.0.1` as a `host` is
    # risky unless you take great care to run this webhook on all hosts
    # which run an apiserver which might need to make calls to this
    # webhook. Such installs are likely to be non-portable, i.e., not easy
    # to turn up in a new cluster.
    # 
    # The scheme must be "https"; the URL must begin with "https://".
    # 
    # A path is optional, and if present may be any string permissible in
    # a URL. You may use the path to pass an arbitrary string to the
    # webhook, for example, a cluster identifier.
    # 
    # Attempting to use a user or basic auth e.g. "user:password@" is not
    # allowed. Fragments ("#...") and query parameters ("?...") are not
    # allowed, either.
    @typechecked
    def url(self) -> Optional[str]:
        return self._kwargs.get('url')
    
    # `service` is a reference to the service for this webhook. Either
    # `service` or `url` must be specified.
    # 
    # If the webhook is running within the cluster, then you should use `service`.
    @typechecked
    def service(self) -> Optional[ServiceReference]:
        return self._kwargs.get('service')
    
    # `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
    # If unspecified, system trust roots on the apiserver are used.
    @typechecked
    def caBundle(self) -> bytes:
        return self._kwargs.get('caBundle', b'')


# MutatingWebhook describes an admission webhook and the resources and operations it applies to.
class MutatingWebhook(types.Object):

    @typechecked
    def render(self) -> addict.Dict:
        v = super().render()
        v['name'] = self.name()
        v['clientConfig'] = self.clientConfig()
        rules = self.rules()
        if rules:  # omit empty
            v['rules'] = rules
        failurePolicy = self.failurePolicy()
        if failurePolicy is not None:  # omit empty
            v['failurePolicy'] = failurePolicy
        matchPolicy = self.matchPolicy()
        if matchPolicy is not None:  # omit empty
            v['matchPolicy'] = matchPolicy
        namespaceSelector = self.namespaceSelector()
        if namespaceSelector is not None:  # omit empty
            v['namespaceSelector'] = namespaceSelector
        objectSelector = self.objectSelector()
        if objectSelector is not None:  # omit empty
            v['objectSelector'] = objectSelector
        sideEffects = self.sideEffects()
        if sideEffects is not None:  # omit empty
            v['sideEffects'] = sideEffects
        timeoutSeconds = self.timeoutSeconds()
        if timeoutSeconds is not None:  # omit empty
            v['timeoutSeconds'] = timeoutSeconds
        admissionReviewVersions = self.admissionReviewVersions()
        if admissionReviewVersions:  # omit empty
            v['admissionReviewVersions'] = admissionReviewVersions
        reinvocationPolicy = self.reinvocationPolicy()
        if reinvocationPolicy is not None:  # omit empty
            v['reinvocationPolicy'] = reinvocationPolicy
        return v
    
    # The name of the admission webhook.
    # Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
    # "imagepolicy" is the name of the webhook, and kubernetes.io is the name
    # of the organization.
    # Required.
    @typechecked
    def name(self) -> str:
        return self._kwargs.get('name', '')
    
    # ClientConfig defines how to communicate with the hook.
    # Required
    @typechecked
    def clientConfig(self) -> WebhookClientConfig:
        return self._kwargs.get('clientConfig', WebhookClientConfig())
    
    # Rules describes what operations on what resources/subresources the webhook cares about.
    # The webhook cares about an operation if it matches _any_ Rule.
    # However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
    # from putting the cluster in a state which cannot be recovered from without completely
    # disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
    # on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
    @typechecked
    def rules(self) -> List[RuleWithOperations]:
        return self._kwargs.get('rules', [])
    
    # FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
    # allowed values are Ignore or Fail. Defaults to Ignore.
    @typechecked
    def failurePolicy(self) -> Optional[FailurePolicyType]:
        return self._kwargs.get('failurePolicy', FailurePolicyType['Ignore'])
    
    # matchPolicy defines how the "rules" list is used to match incoming requests.
    # Allowed values are "Exact" or "Equivalent".
    # 
    # - Exact: match a request only if it exactly matches a specified rule.
    # For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
    # but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
    # a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
    # 
    # - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
    # For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
    # and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
    # a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
    # 
    # Defaults to "Exact"
    @typechecked
    def matchPolicy(self) -> Optional[MatchPolicyType]:
        return self._kwargs.get('matchPolicy', MatchPolicyType['Exact'])
    
    # NamespaceSelector decides whether to run the webhook on an object based
    # on whether the namespace for that object matches the selector. If the
    # object itself is a namespace, the matching is performed on
    # object.metadata.labels. If the object is another cluster scoped resource,
    # it never skips the webhook.
    # 
    # For example, to run the webhook on any objects whose namespace is not
    # associated with "runlevel" of "0" or "1";  you will set the selector as
    # follows:
    # "namespaceSelector": {
    #   "matchExpressions": [
    #     {
    #       "key": "runlevel",
    #       "operator": "NotIn",
    #       "values": [
    #         "0",
    #         "1"
    #       ]
    #     }
    #   ]
    # }
    # 
    # If instead you want to only run the webhook on any objects whose
    # namespace is associated with the "environment" of "prod" or "staging";
    # you will set the selector as follows:
    # "namespaceSelector": {
    #   "matchExpressions": [
    #     {
    #       "key": "environment",
    #       "operator": "In",
    #       "values": [
    #         "prod",
    #         "staging"
    #       ]
    #     }
    #   ]
    # }
    # 
    # See
    # https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
    # for more examples of label selectors.
    # 
    # Default to the empty LabelSelector, which matches everything.
    @typechecked
    def namespaceSelector(self) -> Optional['metav1.LabelSelector']:
        return self._kwargs.get('namespaceSelector')
    
    # ObjectSelector decides whether to run the webhook based on if the
    # object has matching labels. objectSelector is evaluated against both
    # the oldObject and newObject that would be sent to the webhook, and
    # is considered to match if either object matches the selector. A null
    # object (oldObject in the case of create, or newObject in the case of
    # delete) or an object that cannot have labels (like a
    # DeploymentRollback or a PodProxyOptions object) is not considered to
    # match.
    # Use the object selector only if the webhook is opt-in, because end
    # users may skip the admission webhook by setting the labels.
    # Default to the empty LabelSelector, which matches everything.
    @typechecked
    def objectSelector(self) -> Optional['metav1.LabelSelector']:
        return self._kwargs.get('objectSelector')
    
    # SideEffects states whether this webhookk has side effects.
    # Acceptable values are: Unknown, None, Some, NoneOnDryRun
    # Webhooks with side effects MUST implement a reconciliation system, since a request may be
    # rejected by a future step in the admission change and the side effects therefore need to be undone.
    # Requests with the dryRun attribute will be auto-rejected if they match a webhook with
    # sideEffects == Unknown or Some. Defaults to Unknown.
    @typechecked
    def sideEffects(self) -> Optional[SideEffectClass]:
        return self._kwargs.get('sideEffects', SideEffectClass['Unknown'])
    
    # TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
    # the webhook call will be ignored or the API call will fail based on the
    # failure policy.
    # The timeout value must be between 1 and 30 seconds.
    # Default to 30 seconds.
    @typechecked
    def timeoutSeconds(self) -> Optional[int]:
        return self._kwargs.get('timeoutSeconds', 30)
    
    # AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
    # versions the Webhook expects. API server will try to use first version in
    # the list which it supports. If none of the versions specified in this list
    # supported by API server, validation will fail for this object.
    # If a persisted webhook configuration specifies allowed versions and does not
    # include any versions known to the API Server, calls to the webhook will fail
    # and be subject to the failure policy.
    # Default to `['v1beta1']`.
    @typechecked
    def admissionReviewVersions(self) -> List[str]:
        return self._kwargs.get('admissionReviewVersions', [])
    
    # reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
    # Allowed values are "Never" and "IfNeeded".
    # 
    # Never: the webhook will not be called more than once in a single admission evaluation.
    # 
    # IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
    # if the object being admitted is modified by other admission plugins after the initial webhook call.
    # Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
    # Note:
    # * the number of additional invocations is not guaranteed to be exactly one.
    # * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
    # * webhooks that use this option may be reordered to minimize the number of additional invocations.
    # * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
    # 
    # Defaults to "Never".
    @typechecked
    def reinvocationPolicy(self) -> Optional[ReinvocationPolicyType]:
        return self._kwargs.get('reinvocationPolicy', ReinvocationPolicyType['Never'])


# MutatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and may change the object.
# Deprecated in v1.16, planned for removal in v1.19. Use admissionregistration.k8s.io/v1 MutatingWebhookConfiguration instead.
class MutatingWebhookConfiguration(base.TypedObject, base.MetadataObject):

    @typechecked
    def render(self) -> addict.Dict:
        v = super().render()
        webhooks = self.webhooks()
        if webhooks:  # omit empty
            v['webhooks'] = webhooks.values()  # named list
        return v
    
    @typechecked
    def apiVersion(self) -> str:
        return 'admissionregistration.k8s.io/v1beta1'
    
    @typechecked
    def kind(self) -> str:
        return 'MutatingWebhookConfiguration'
    
    # Webhooks is a list of webhooks and the affected resources and operations.
    @typechecked
    def webhooks(self) -> Dict[str, MutatingWebhook]:
        return self._kwargs.get('webhooks', addict.Dict())


# ValidatingWebhook describes an admission webhook and the resources and operations it applies to.
class ValidatingWebhook(types.Object):

    @typechecked
    def render(self) -> addict.Dict:
        v = super().render()
        v['name'] = self.name()
        v['clientConfig'] = self.clientConfig()
        rules = self.rules()
        if rules:  # omit empty
            v['rules'] = rules
        failurePolicy = self.failurePolicy()
        if failurePolicy is not None:  # omit empty
            v['failurePolicy'] = failurePolicy
        matchPolicy = self.matchPolicy()
        if matchPolicy is not None:  # omit empty
            v['matchPolicy'] = matchPolicy
        namespaceSelector = self.namespaceSelector()
        if namespaceSelector is not None:  # omit empty
            v['namespaceSelector'] = namespaceSelector
        objectSelector = self.objectSelector()
        if objectSelector is not None:  # omit empty
            v['objectSelector'] = objectSelector
        sideEffects = self.sideEffects()
        if sideEffects is not None:  # omit empty
            v['sideEffects'] = sideEffects
        timeoutSeconds = self.timeoutSeconds()
        if timeoutSeconds is not None:  # omit empty
            v['timeoutSeconds'] = timeoutSeconds
        admissionReviewVersions = self.admissionReviewVersions()
        if admissionReviewVersions:  # omit empty
            v['admissionReviewVersions'] = admissionReviewVersions
        return v
    
    # The name of the admission webhook.
    # Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
    # "imagepolicy" is the name of the webhook, and kubernetes.io is the name
    # of the organization.
    # Required.
    @typechecked
    def name(self) -> str:
        return self._kwargs.get('name', '')
    
    # ClientConfig defines how to communicate with the hook.
    # Required
    @typechecked
    def clientConfig(self) -> WebhookClientConfig:
        return self._kwargs.get('clientConfig', WebhookClientConfig())
    
    # Rules describes what operations on what resources/subresources the webhook cares about.
    # The webhook cares about an operation if it matches _any_ Rule.
    # However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
    # from putting the cluster in a state which cannot be recovered from without completely
    # disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
    # on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
    @typechecked
    def rules(self) -> List[RuleWithOperations]:
        return self._kwargs.get('rules', [])
    
    # FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
    # allowed values are Ignore or Fail. Defaults to Ignore.
    @typechecked
    def failurePolicy(self) -> Optional[FailurePolicyType]:
        return self._kwargs.get('failurePolicy', FailurePolicyType['Ignore'])
    
    # matchPolicy defines how the "rules" list is used to match incoming requests.
    # Allowed values are "Exact" or "Equivalent".
    # 
    # - Exact: match a request only if it exactly matches a specified rule.
    # For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
    # but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
    # a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
    # 
    # - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
    # For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
    # and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
    # a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
    # 
    # Defaults to "Exact"
    @typechecked
    def matchPolicy(self) -> Optional[MatchPolicyType]:
        return self._kwargs.get('matchPolicy', MatchPolicyType['Exact'])
    
    # NamespaceSelector decides whether to run the webhook on an object based
    # on whether the namespace for that object matches the selector. If the
    # object itself is a namespace, the matching is performed on
    # object.metadata.labels. If the object is another cluster scoped resource,
    # it never skips the webhook.
    # 
    # For example, to run the webhook on any objects whose namespace is not
    # associated with "runlevel" of "0" or "1";  you will set the selector as
    # follows:
    # "namespaceSelector": {
    #   "matchExpressions": [
    #     {
    #       "key": "runlevel",
    #       "operator": "NotIn",
    #       "values": [
    #         "0",
    #         "1"
    #       ]
    #     }
    #   ]
    # }
    # 
    # If instead you want to only run the webhook on any objects whose
    # namespace is associated with the "environment" of "prod" or "staging";
    # you will set the selector as follows:
    # "namespaceSelector": {
    #   "matchExpressions": [
    #     {
    #       "key": "environment",
    #       "operator": "In",
    #       "values": [
    #         "prod",
    #         "staging"
    #       ]
    #     }
    #   ]
    # }
    # 
    # See
    # https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
    # for more examples of label selectors.
    # 
    # Default to the empty LabelSelector, which matches everything.
    @typechecked
    def namespaceSelector(self) -> Optional['metav1.LabelSelector']:
        return self._kwargs.get('namespaceSelector')
    
    # ObjectSelector decides whether to run the webhook based on if the
    # object has matching labels. objectSelector is evaluated against both
    # the oldObject and newObject that would be sent to the webhook, and
    # is considered to match if either object matches the selector. A null
    # object (oldObject in the case of create, or newObject in the case of
    # delete) or an object that cannot have labels (like a
    # DeploymentRollback or a PodProxyOptions object) is not considered to
    # match.
    # Use the object selector only if the webhook is opt-in, because end
    # users may skip the admission webhook by setting the labels.
    # Default to the empty LabelSelector, which matches everything.
    @typechecked
    def objectSelector(self) -> Optional['metav1.LabelSelector']:
        return self._kwargs.get('objectSelector')
    
    # SideEffects states whether this webhookk has side effects.
    # Acceptable values are: Unknown, None, Some, NoneOnDryRun
    # Webhooks with side effects MUST implement a reconciliation system, since a request may be
    # rejected by a future step in the admission change and the side effects therefore need to be undone.
    # Requests with the dryRun attribute will be auto-rejected if they match a webhook with
    # sideEffects == Unknown or Some. Defaults to Unknown.
    @typechecked
    def sideEffects(self) -> Optional[SideEffectClass]:
        return self._kwargs.get('sideEffects', SideEffectClass['Unknown'])
    
    # TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
    # the webhook call will be ignored or the API call will fail based on the
    # failure policy.
    # The timeout value must be between 1 and 30 seconds.
    # Default to 30 seconds.
    @typechecked
    def timeoutSeconds(self) -> Optional[int]:
        return self._kwargs.get('timeoutSeconds', 30)
    
    # AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
    # versions the Webhook expects. API server will try to use first version in
    # the list which it supports. If none of the versions specified in this list
    # supported by API server, validation will fail for this object.
    # If a persisted webhook configuration specifies allowed versions and does not
    # include any versions known to the API Server, calls to the webhook will fail
    # and be subject to the failure policy.
    # Default to `['v1beta1']`.
    @typechecked
    def admissionReviewVersions(self) -> List[str]:
        return self._kwargs.get('admissionReviewVersions', [])


# ValidatingWebhookConfiguration describes the configuration of and admission webhook that accept or reject and object without changing it.
# Deprecated in v1.16, planned for removal in v1.19. Use admissionregistration.k8s.io/v1 ValidatingWebhookConfiguration instead.
class ValidatingWebhookConfiguration(base.TypedObject, base.MetadataObject):

    @typechecked
    def render(self) -> addict.Dict:
        v = super().render()
        webhooks = self.webhooks()
        if webhooks:  # omit empty
            v['webhooks'] = webhooks.values()  # named list
        return v
    
    @typechecked
    def apiVersion(self) -> str:
        return 'admissionregistration.k8s.io/v1beta1'
    
    @typechecked
    def kind(self) -> str:
        return 'ValidatingWebhookConfiguration'
    
    # Webhooks is a list of webhooks and the affected resources and operations.
    @typechecked
    def webhooks(self) -> Dict[str, ValidatingWebhook]:
        return self._kwargs.get('webhooks', addict.Dict())
